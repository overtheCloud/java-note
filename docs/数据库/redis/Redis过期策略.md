### 过期策略

- 定时删除

设置键的过期时间时，创建一个 Timer ，当过期时间到临时，立刻删除键。

内存友好型策略，一旦键过期，就会被删除，并释放所占用的内存，Cpu 不友好，当一批数量比较多的键过期时，正好遇上Cpu 紧张的时段，这时候需要的是Cpu处理能力，而不是内存，显然 Cpu 时间用在删除过期键上，会对服务器的响应时间和吞吐量造成影响。另外当前 Redis 时间事件（无序链表O(N)）无法高效处理大量时间事件，所以定时删除并不是一种好的定时删除策略

- 惰性删除

不管过期的键，在这种策略下，当键在键空间中被取出时，首先检查取出的键是否过期，若过期删除该键，否则，返回该键。

很明显，惰性删除依赖过期键的被动访问，对于内存不友好，如果一些键长期没有被访问，会造成内存泄露（垃圾数据占用内存）。我们知道，Redis是依赖内存的，所以惰性删除也不是一个好的策略。

### 过期淘汰策略

- volatile-lru ：在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把 redis 既当缓存，又做持久化存储的时候才用。
- volatile-random ： 在设置了过期时间的键空间中，随机移除一个键（不推荐）
- volatile-ttl ： 在设置了过期时间的键空间中，有更早过期时间的key优先移除 （不推荐）
- allkeys-lru ： 移除最近最少使用的key （推荐）
- allkeys-random ： 直接在键空间中随机移除一个键（不推荐）
- noeviction ： 不做过键处理，只返回一个写操作错误（默认，不推荐）

