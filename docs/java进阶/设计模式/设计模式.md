### 设计模式原则

|              | 描述                                           |
| ------------ | ---------------------------------------------- |
| 里氏代换原则 | 基类适用的一定也适用于子类                     |
| 开闭原则     | 对扩展开放，对修改关闭                         |
| 依赖倒转     | 具体实现依赖于抽象定义                         |
| 接口隔离     | 一个类对另一个类的依赖性应当建立在最小的接口上 |
| 单一职责     | 一个类只负责一个功能领域中的相应职责           |
| 迪米特原则   | 降低接口间的耦合度                             |



### 创建型模式

|                           | 描述                                                         | 适用场景                                                     | 缺点               | 应用                                                         |
| ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------ | ------------------------------------------------------------ |
| 简单工厂模式              | 专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类 | 创建的对象较少                                               | 扩展性差           | `DateFormat.getDateInstance()`<br>`KeyGenerator.getInstance("DESede")` |
| 工厂方法模式              | 工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类 | 创建单个类                                                   | 复杂度高           | `DriverManager.getConnection()`                              |
| 抽象工厂模式              | 每个工厂实现类创建同一类下的多个类<br />例如：轿车工厂类创建所有轿车的轮胎、玻璃等，越野车工厂类创建所有越野车的轮胎、玻璃等。 | 创建多个类                                                   | 复杂度高           | spring                                                       |
| 建造者模式                | 将一个复杂对象的构建与它的表示分离，使得 同样的构建过程可以创建不同的表示。 | 生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性 |                    |                                                              |
| 原型模式                  | 通过复制生成实例                                             |                                                              | 不适合修改已有的类 | new Object()                                                 |
| [单例模式](单例模式.md) | 只有一个实例<br />创建方式：饿汉模式，懒汉模式（双重校验锁，注意实例要用 volidate 修饰） | 全局唯一对象                                                 |                    | 线程池、缓存                                                 |



### 结构型模式

|                               | 描述                                                         | 适用场景                                                     | 缺点                                                       | 应用                                                         |
| ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------------------- | ------------------------------------------------------------ |
| 适配器模式                    | 把一个类的接口变成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作，与`装饰模式`同样具有包装的功能 | 想使用一个已经存在的类，而它的接口不符合你的需求，或者你想创建一个可重用的类 | 过多使用会导致系统凌乱，追溯困难                           | `java.util.Arrays#asList()` `java.io.InputStreamReader(InputStream)` `java.io.OutputStreamWriter(OutputStream)`<br />Spring 的 AOP |
| 桥接模式                      | 将抽象部分与它的实现部分分离，使它们都可以独立地变化.将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量 | 抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合 | 增加系统的理解与设计难度                                   | AWT 中的 Peer                                                |
| 组合模式                      | 把一组相似的对象当作一个单一的对象,形成树状结构              | 树型菜单、树型类目、文件和文件夹                             | 叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则 | JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝 |
| [装饰者模式](装饰者模式.md) | 动态地给一个对象添加一些额外的职责                           | 不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责 | 增加系统的复杂度                                           |                                                              |
| 外观模式                      | 隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口，又称门面模式 | 为复杂的模块或子系统提供外界访问的统一模块                   |                                                            | SL4J                                                         |
| 享元模式                      | 共享相同或者相似的细粒度对象，减少对象数量，提高对象复用     |                                                              | 逻辑复杂，性能开销大                                       | String 常量池                                                |
| [代理模式](代理模式.md)     | 使用代理对象完成用户请求，屏蔽用户对真实对象的访问           |                                                              | 增加复杂度和性能消耗                                       | 动态代理<br />Spring AOP                                     |



### 行为型模式

|                            | 描述                                                         | 适用场景                                                     | 缺点                   | 应用                                                         |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------- | ------------------------------------------------------------ |
| 职责链模式                 | 多个对象串行执行                                             | 校验、日志                                                   |                        | servlet 中的 filter<br />dubbo 中的 filter<br />Mybatis 中的 plugin |
| 命令模式                   | 将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。 | 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互 |                        | AWT 的事件委派机制                                           |
| 解释器模式                 | 通过定义解释语句                                             |                                                              |                        |                                                              |
| 迭代器模式                 | 顺序访问集合元素而不暴露聚集的内部表象                       | 遍历集合                                                     | 遍历顺序无序           | Iterator                                                     |
| 中介者模式                 | 交互的双方通过第三方交互，实现解耦                           | 对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解 | 复杂度高               | 聊天室的服务器                                               |
| 备忘录模式                 | 存储对象的快照                                               |                                                              |                        |                                                              |
| [观察者模式](观察者模式.md) | 建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应 | 监听器 、发布订阅模式                                        | 监听对象多时性能消耗高 |                                                              |
| 状态模式                   | 让一个对象再其内部状态改变时行为也随之改变                   | 一个对象的行为依赖于它所处的状态                             | 增加复杂度             | TCP                                                          |
| 策略模式                   | 完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务 | 使用策略模式优化 switch 代码                                 | 增加代码量和复杂度     |                                                              |
| 模板方法模式               | 抽象一个类，实现部分逻辑，然后在不同子类中实现不同的剩余逻辑 | 复用代码                                                     |                        | HttpServlet                                                  |
| 访问者模式                 | 封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改，接受这个操作的数据结构则可以保持不变 | 被访问的类结构非常稳定                                       | 修改困难               |                                                              |

