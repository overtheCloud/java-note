## synchronized

重量级锁，解决多线程间的同步性，修饰方法和代码块，基于监视器锁（monitor）实现。

**Synchronized 的锁对象**：

- 对于普通方法，锁是当前实例对象
- 对于静态同步方法，锁是当前类的 Class 对象
- 对于同步代码块，锁是 Synchronized 括号里的对象

**实现原理**

- 修饰方法时，转成汇编后有 ACC_SYNCHRONIZED  标识表示该方法是同步方法。
- 修饰代码块时，转成汇编后代码块开始位置增加了 **monitorenter**  指令，代码块结束位置增加了 **monitorexit**  指令。当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。

**特性**

- 可重入锁：同以线程可多次进入已获取锁的 synchronized 代码内

1.6 之前 synchronized 是重量级锁，性能低， 1.6 进行了优化，引入了 **偏向锁** 和  **轻量级锁**。锁一共有4个状态，锁可以升级不能降级，目的是提升获取锁和释放锁的效率。

- 无锁状态
- 偏向锁：线程访问同步块时会在对象头和栈帧中的锁记录存储偏向锁的线程 ID，该线程下次进入同步块时无需进行 CAS 加锁和解锁，其他线程尝试进入同步块产生竞争时撤销偏向锁
- 轻量级锁：线程进入同步块后会复制对象头的 `Mark Word`，然后尝试 CAS 替换对象头的 `Mark Word` 为指向锁记录的指针，成功表示获取锁，失败则表示有竞争，当前线程使用自旋获取锁。
- 重量级锁：锁对象被持有后阻塞其他尝试获取锁的线程